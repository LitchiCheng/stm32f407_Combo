

#include <stm32f4xx.h>
#include <stdint.h>
#include "sensirion_arch_config.h"
#include "sensirion_i2c.h"

static I2C_InitTypeDef hi2c1;
static GPIO_InitTypeDef gpioinit;
static uint32_t I2Cx_TIMEOUT_UserCallback(char value);

#define I2Cx_FLAG_TIMEOUT			((uint32_t) 900)
#define I2Cx_LONG_TIMEOUT 			((uint32_t)(300 * I2Cx_FLAG_TIMEOUT))
#define WAIT_FOR_FLAG(flag, value, timeout, errorcode)	I2CTimeout = timeout;\
														while(I2C_GetFlagStatus(I2C1, flag) != value){\
														if((I2CTimeout--) == 0) return I2Cx_TIMEOUT_UserCallback(errorcode);\
														}\

#define CLEAR_ADDR_BIT			I2C_ReadRegister(I2C1, I2C_Register_SR1);\
								I2C_ReadRegister(I2C1, I2C_Register_SR2);\

static uint32_t I2Cx_TIMEOUT_UserCallback(char value)
{
	I2C_InitTypeDef hi2c1;
	I2C_GenerateSTOP(I2C1, ENABLE);
	I2C_SoftwareResetCmd(I2C1, ENABLE);
	I2C_SoftwareResetCmd(I2C1, DISABLE);
	I2C_DeInit(I2C1);
	hi2c1.I2C_ClockSpeed = 100000;
    hi2c1.I2C_Mode = I2C_Mode_I2C;
    hi2c1.I2C_DutyCycle = I2C_DutyCycle_2;
    hi2c1.I2C_OwnAddress1 = 0;
    hi2c1.I2C_Ack = I2C_Ack_Enable;
    hi2c1.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
	I2C_Cmd(I2C1, ENABLE);
	I2C_Init(I2C1, &hi2c1);
	//Console::Instance()->printf("I2C1 Restarted. \n");
	return 1;
}
 
 s8 I2C_WriteBlock(uint8_t w_addr, const uint8_t* p_data, uint16_t len)
{
	
	uint16_t i = 0;
	__IO uint32_t I2CTimeout = I2Cx_LONG_TIMEOUT;
	WAIT_FOR_FLAG(I2C_FLAG_BUSY,RESET,I2Cx_LONG_TIMEOUT,1);	
	I2C_GenerateSTART(I2C1, ENABLE);
	WAIT_FOR_FLAG(I2C_FLAG_SB, SET, I2Cx_FLAG_TIMEOUT, 2);
	I2C_Send7bitAddress(I2C1,(w_addr << 1), I2C_Direction_Transmitter);
	WAIT_FOR_FLAG(I2C_FLAG_ADDR, SET, I2Cx_FLAG_TIMEOUT, 3);
	CLEAR_ADDR_BIT;
	while (i < len) 
	{
		I2C_SendData(I2C1, *p_data);
		WAIT_FOR_FLAG(I2C_FLAG_TXE, SET, I2Cx_FLAG_TIMEOUT, 4);
		i++; p_data++;
	}
	WAIT_FOR_FLAG(I2C_FLAG_BTF, SET, I2Cx_FLAG_TIMEOUT, 5);
	I2C_GenerateSTOP(I2C1, ENABLE);
	return 0;
}

s8 I2C_ReadBlock(uint8_t r_addr, uint8_t* p_data, uint16_t len)
{
	__IO uint32_t I2CTimeout = I2Cx_LONG_TIMEOUT;
	WAIT_FOR_FLAG(I2C_FLAG_BUSY,RESET,I2Cx_LONG_TIMEOUT,6);
	I2C_GenerateSTART(I2C1, ENABLE);
	WAIT_FOR_FLAG(I2C_FLAG_SB, SET, I2Cx_FLAG_TIMEOUT, 7);
	I2C_Send7bitAddress(I2C1, (r_addr << 1), I2C_Direction_Transmitter);
	WAIT_FOR_FLAG(I2C_FLAG_ADDR, SET, I2Cx_FLAG_TIMEOUT, 8);
	CLEAR_ADDR_BIT;
	WAIT_FOR_FLAG (I2C_FLAG_TXE, SET, I2Cx_FLAG_TIMEOUT, 9);
	I2C_SendData(I2C1,r_addr);
	WAIT_FOR_FLAG (I2C_FLAG_TXE, SET, I2Cx_FLAG_TIMEOUT, 10); 
	I2C_GenerateSTART(I2C1, ENABLE);
	WAIT_FOR_FLAG (I2C_FLAG_SB, SET, I2Cx_FLAG_TIMEOUT, 11);
	
	I2C_Send7bitAddress(I2C1,(r_addr << 1), I2C_Direction_Receiver);
	
	WAIT_FOR_FLAG (I2C_FLAG_ADDR, SET, I2Cx_FLAG_TIMEOUT, 12);
	/*规定死就2个长度*/
//	I2C_AcknowledgeConfig(I2C1, DISABLE);
//	I2C1->CR1 |= I2C_CR1_POS;
//	CLEAR_ADDR_BIT;
//	WAIT_FOR_FLAG (I2C_FLAG_BTF, SET, I2Cx_FLAG_TIMEOUT, 13);
//	I2C_GenerateSTOP(I2C1, ENABLE);
//	*p_data = I2C_ReceiveData(I2C1);
//	p_data++;
//	*p_data = I2C_ReceiveData(I2C1);
//	I2C_ClearFlag(I2C1,I2C_FLAG_BTF);
//	WAIT_FOR_FLAG(I2C_FLAG_BUSY,RESET,I2Cx_LONG_TIMEOUT,14);
//	I2C_AcknowledgeConfig(I2C1, ENABLE);
//	I2C1->CR1 &= ~I2C_CR1_POS;
	while(len) 
	{
		if (len == 1)
		{
			I2C_AcknowledgeConfig(I2C1, DISABLE);
			I2C_GenerateSTOP(I2C1, ENABLE);
		}
		if (I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_RECEIVED))
		{
			*p_data = I2C_ReceiveData(I2C1);
			p_data++;
			len--;
		}
	}
	I2C_AcknowledgeConfig(I2C1, ENABLE);
	return 0;
} 

void sensirion_i2c_init()
{


	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);
	gpioinit.GPIO_Mode = GPIO_Mode_OUT;
	gpioinit.GPIO_OType = GPIO_OType_PP;
	gpioinit.GPIO_PuPd = GPIO_PuPd_UP;
	gpioinit.GPIO_Pin = GPIO_Pin_8 | GPIO_Pin_7;
	gpioinit.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(GPIOB, &gpioinit);
	GPIO_SetBits(GPIOB, GPIO_Pin_7);
	GPIO_SetBits(GPIOB, GPIO_Pin_8);
	I2C_SoftwareResetCmd(I2C1, ENABLE);

	
	gpioinit.GPIO_Mode = GPIO_Mode_AF;
	gpioinit.GPIO_OType = GPIO_OType_OD;
	gpioinit.GPIO_Pin = GPIO_Pin_8 | GPIO_Pin_7;
	gpioinit.GPIO_PuPd = GPIO_PuPd_NOPULL;
	gpioinit.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_PinAFConfig(GPIOB,GPIO_PinSource8,GPIO_AF_I2C1);
	GPIO_PinAFConfig(GPIOB,GPIO_PinSource7,GPIO_AF_I2C1);
	GPIO_Init(GPIOB, &gpioinit);
	
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C1,ENABLE);
    hi2c1.I2C_ClockSpeed = 100000;
    hi2c1.I2C_Mode = I2C_Mode_I2C;
    hi2c1.I2C_DutyCycle = I2C_DutyCycle_16_9;
    hi2c1.I2C_OwnAddress1 = 0;
    hi2c1.I2C_Ack = I2C_Ack_Enable;
    hi2c1.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
	I2C_Cmd(I2C1, ENABLE);
	I2C_Init(I2C1, &hi2c1);
    /* Enable the remapping of Pins 6/7 to 8/9 and the I2C clock before the
     * initialization of the GPIO Pins in HAL_I2C_Init(). This is a fix of the
     * code generated by CubeMX v4.16.0 */
}

/**
 * Execute one read transaction on the I2C bus, reading a given number of bytes.
 * If the device does not acknowledge the read command, an error shall be
 * returned.
 *
 * @param address 7-bit I2C address to read from
 * @param data    pointer to the buffer where the data is to be stored
 * @param count   number of bytes to read from I2C and store in the buffer
 * @returns 0 on success, error code otherwise
 */
s8 sensirion_i2c_read(u8 address, u8 *data, u16 count)
{
    return (s8) I2C_ReadBlock(address, data, count);
}

/**
 * Execute one write transaction on the I2C bus, sending a given number of bytes.
 * The bytes in the supplied buffer must be sent to the given address. If the
 * slave device does not acknowledge any of the bytes, an error shall be
 * returned.
 *
 * @param address 7-bit I2C address to write to
 * @param data    pointer to the buffer containing the data to write
 * @param count   number of bytes to read from the buffer and send over I2C
 * @returns 0 on success, error code otherwise
 */
s8 sensirion_i2c_write(u8 address, const u8 *data, u16 count)
{
    return (s8) I2C_WriteBlock(address,data, count);
}

/**
 * Sleep for a given number of microseconds. The function should delay the
 * execution for at least the given time, but may also sleep longer.
 *
 * @param useconds the sleep time in microseconds
 */
void sensirion_sleep_usec(u32 useconds) {
//    u32 msec = useconds / 1000;
//    if (useconds % 1000 > 0) {
//        msec++;
//    }

//    /*
//     * Increment by 1 if STM32F1 driver version less than 1.1.1
//     * Old firmwares of STM32F1 sleep 1ms shorter than specified in HAL_Delay.
//     * This was fixed with firmware 1.6 (driver version 1.1.1), so we have to
//     * fix it ourselves for older firmwares
//     */
//    if (HAL_GetHalVersion() < 0x01010100) {
//        msec++;
//    }

//    HAL_Delay(msec);
}
